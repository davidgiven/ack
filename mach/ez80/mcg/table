OPTIONS

    EMIT_CONSTANTS_AS_LITTLE_ENDIAN_BYTES;
    FLOAT_NOT_SUPPORTED;
    NO_BOUNDS_CHECKING;

REGISTERS

    /* Registers are allocated top down. The odd order below is to make sure
     * that cheap registers get allocated first.
     *
     * Registers may have at most one of: int, float, long, double. These
     * indicate that the register is used to store a value of that type. If
     * your register can store more than one type, create an alias. Registers
     * with none of these cannot be copied by the code generator (and so cannot
     * be moved from register to register or spilt).
     */

    hl named("hl", "l")                         int basereg bindirreg hlreg indirreg volatile;
    de named("de", "e")                         int basereg dereg volatile iret;
    bc named("bc", "c")                         int basereg bcreg volatile;
    #if 0
    ix                                          int ixreg bindirreg indirreg volatile;
    #endif

    hlhl aliases(hl) named("hl")                long hlhlreg volatile;
    dede aliases(de) named("de")                long dedereg volatile lret;
    bcbc aliases(bc) named("bc")                long bcbcreg volatile;

    fhl aliases(hl) named("hl")                 float volatile;
    fde aliases(de) named("de")                 float volatile fret;
    fbc aliases(bc) named("bc")                 float volatile;

    dhl aliases(hl) named("hl")                 double volatile;
    dde aliases(de) named("de")                 double volatile dret;
    dbc aliases(bc) named("bc")                 double volatile;

    flags                                       flags;


DECLARATIONS

    ubyteX;   /* bottom 8 bits valid, the rest undefined */
    ubyte0;   /* bottom 8 bits valid, the rest 0 */
    flags;    /* flags set after a comparison */

	address fragment;



PATTERNS

/* Special */

	PAIR(BLOCK.I, BLOCK.I);


/* Miscellaneous special things */

    out:(int)reg = POP.I
        emit "pop %out"
        cost 2;

    out:(float)reg = POP.F
        emit "pop %out"
        cost 2;

    out:(long)reg = POP.L
        emit "pop %out"
        emit "exx"
        emit "pop %out"
        emit "exx"
        cost 6;

    PUSH.F(in:(float)reg)
        emit "push %in"
        cost 2;

    PUSH.I(in:(int)reg)
        emit "push %in"
        cost 2;

    PUSH.I(offset:LOCAL.I)
        when signed_constant(%offset, 8)
        emit "pea iy+$offset"
        cost 3;

    PUSH.L(in:(long)reg)
        emit "exx"
        emit "push %in"
        emit "exx"
        emit "push %in"
        cost 6;

    SETRET.I(in:(iret)reg)
        emit "! setret.i"
        cost 1;

    SETRET.L(in:(lret)reg)
        emit "! setret.l"
        cost 1;

    out:(int)reg = value:CONST.I
        emit "ld %out, $value"
        cost 5;

    out:(long)reg = value:CONST.L
        emit "ld %out, $value & 0xffffff"
        emit "exx"
        emit "ld %out, $value >> 24"
        emit "exx"
        cost 5;

    out:(int)reg = value:LABEL.I
        emit "ld %out, $value"
        cost 5;

    out:(int)reg = value:BLOCK.I
        emit "ld %out, $value"
        cost 5;

    STACKADJUST.I(amount:CONST.I)
        when specific_constant(%amount, 3)
        emit "pop af"
        cost 1;

    STACKADJUST.I(amount:CONST.I)
        when specific_constant(%amount, 6)
        emit "pop af"
        emit "pop af"
        cost 2;

    STACKADJUST.I(amount:CONST.I)
        when specific_constant(%amount, 9)
        emit "pop af"
        emit "pop af"
        emit "pop af"
        cost 3;

    STACKADJUST.I(in:(hlreg)reg)
        emit "add hl, sp"
        emit "ld sp, hl"
        cost 5;

    STACKADJUST.I(in:(hlreg)reg)
        emit "add hl, sp"
        emit "ld sp, hl"
        cost 5;

    SETFP.I(in:(int)reg)
        emit "push %in"
        emit "pop iy"
        cost 5;

    out:(int)reg = GETFP.I
        emit "lea %out, iy"
        cost 5;

    out:(hlreg)reg = GETSP.I
        emit "ld hl, 0"
        emit "add hl, sp"
        cost 5;

    SETSP.I(in:(hlreg)reg)
        emit "ld sp, %in"
        cost 5;

    out:(int)reg = CHAINFP.I(in:(indirreg)reg)
        emit "ld %out, (%in)"
        cost 5;

    out:(hlreg)reg = FPTOAB.I(in:(int)reg)
        with preserved(%in)
        emit "ld %out, 6"
        emit "add hl, %in"
        cost 5;

    out:(int)reg = FPTOLB.I(in:(int)reg)
        with %out == %in
        cost 1;


/* Locals and stack-relatives */

    address = offset:LOCAL.I
        when signed_constant(%offset, 8)
        emit "iy+$offset"
        cost 1;

    address = GETFP.I
        emit "iy"
        cost 1;

    address = ADD.I(GETFP.I, offset:CONST.I)
        when signed_constant(%offset, 8)
        emit "iy+$offset"
        cost 1;

    out:(hlreg)reg = offset:LOCAL.I
        with corrupted(bcreg)
        when !signed_constant(%offset, 8)
        emit "push iy"
        emit "pop hl"
        emit "ld bc, $offset+6"
        emit "add hl, bc"
        cost 8;

    address = in:LABEL.I
        emit "$in"
        cost 1;

    out:(int)reg = addr:address
        emit "lea %out, %addr"
        cost 5;



/* Memory loads and stores */

    out:(int)reg = LOAD.I(addr:address)
        emit "ld %out, (%addr)"
        cost 2;

    STORE.I(addr:address, val:(int)reg)
        emit "ld (%addr), %val"
        cost 2;

    out:(int)reg = LOAD.I(in:(indirreg)reg)
        emit "ld %out, (%in)"
        cost 2;

    STORE.I(ptr:(indirreg)reg, val:(int)reg)
        emit "ld (%ptr), %val"
        cost 2;

    out:(long)reg = LOAD.L(addr:address)
        emit "exx"
        emit "ld %out, (%addr+3)"
        emit "exx"
        emit "ld %out, (%addr+0)"
        cost 10;

    out:(float)reg = LOAD.F(addr:address)
        emit "ld %out, (%addr)"
        cost 2;

    out:(float)reg = LOAD.F(in:(indirreg)reg)
        emit "ld %out, (%in)"
        cost 2;

    STORE.F(ptr:(indirreg)reg, val:(float)reg)
        emit "ld (%ptr), %val"
        cost 2;

    out:(lret)reg = LOAD.L(in:(hlreg)reg)
        with preserved(%in), corrupted(hlreg)
        emit "ld %out, (%in)"
        emit "exx"
        emit "inc %in"
        emit "inc %in"
        emit "inc %in"
        emit "ld %out, (%in)"
        emit "exx"
        cost 8;

    STORE.L(ptr:(hlreg)reg, val:(lret)reg)
        with corrupted(hlreg), corrupted(lret)
        emit "ld (%ptr), %val"
        emit "exx"
        emit "push %val"
        emit "exx"
        emit "pop %val"
        emit "inc %ptr"
        emit "inc %ptr"
        emit "inc %ptr"
        emit "ld (%ptr), %val"
        cost 8;

    #if 0
    out:(long)reg = LOAD.L(in:(ixreg)reg)
        emit "exx"
        emit "ld %out, (%in+3)"
        emit "exx"
        emit "ld %out, (%in+0)"
        cost 8;

    STORE.L(ptr:(ixreg)reg, val:(long)reg)
        emit "ld (%ptr+0), %val"
        emit "exx"
        emit "ld (%ptr+3), %val"
        emit "exx"
        cost 8;
    #endif


/* Byte stuff */

    out:(basereg)ubyteX = LOADB.I(in:(bindirreg)reg)
        emit "ld %out.1, (%in)"
        cost 2;

    out:(basereg)reg = LOADB.I(in:(basereg)reg)
        emit "ld a, (%in)"
        emit "ld %out, 0"
        emit "ld %out.1, a"
        cost 4;

    STOREB.I(ptr:(bindirreg)reg, val:(basereg)reg)
        emit "ld (%ptr), %val.1"
        cost 3;

    out:(int)reg = in:(int)ubyteX
        with preserved(%in)
        emit "ld %out, 0"
        emit "ld %out.1, %in.1"
        cost 2;

    out:(hlreg)reg = EXTENDB.I(in:(hlreg)reg)
        emit "call .extendb"
        cost 10;

    out:(hlreg)reg = EXTENDB.I(in:(hlreg)ubyteX)
        emit "call .extendb"
        cost 10;




/* Word arithmetic */

    out:(int)reg = NOP.I(in:(int)reg)
        with %out == %in
        cost 1;

    out:(int)reg = FROMSI.I(in:(int)reg)
        with %out == %in
        cost 1;

    out:(int)reg = FROMUI.I(in:(int)reg)
        with %out == %in
        cost 1;

    out:(hlreg)reg = ADD.I(left:(hlreg)reg, right:(basereg)reg)
    with %out == %left
        emit "add %out, %right"
        cost 2;

    out:(int)reg = ADD.I(left:(int)reg, one:CONST.I)
    with %out == %left
    when specific_constant(%one, 1)
        emit "inc %left"
        cost 2;

    out:(hlreg)reg = SUB.I(left:(hlreg)reg, right:(basereg)reg)
    with %out == %left
        emit "and a"
        emit "sbc %out, %right"
        cost 3;

    out:(int)reg = SUB.I(left:(int)reg, one:CONST.I)
    with %out == %left
    when specific_constant(%one, 1)
        emit "dec %left"
        cost 2;

    out:(hlreg)reg = NEG.I(left:(basereg)reg)
        with preserved(%left)
        emit "ld %out, 0"
        emit "and a"
        emit "sbc %out, %left"
        cost 3;

    out:(dereg)reg = DIV.I(left:(dereg)reg, right:(bcreg)reg)
        emit "call .rmsdvs3"
        cost 14;

    out:(hlreg)reg = MOD.I(left:(dereg)reg, right:(bcreg)reg)
        emit "call .rmsdvs3"
        cost 14;

    out:(dereg)reg = DIVU.I(left:(dereg)reg, right:(bcreg)reg)
        emit "call .rmudvu3"
        cost 14;

    out:(hlreg)reg = MODU.I(left:(dereg)reg, right:(bcreg)reg)
        emit "call .rmudvu3"
        cost 14;

    out:(hlreg)reg = MUL.I(left:(bcreg)reg, right:(dereg)reg)
        emit "call .mli3"
        cost 14;

    out:(hlreg)reg = NOT.I(left:(hlreg)reg)
        with %out == %left
        emit "call .not3"
        cost 5;

    out:(int)reg = FROMSL.I(in:(long)reg)
        emit "push %in"
        emit "pop %out"
        cost 5;

    out:(int)reg = FROMUL.I(in:(long)reg)
        emit "push %in"
        emit "pop %out"
        cost 5;




/* Simple (call out to helper) arithmetic operations. */

    #define ALUOP(op, helper) \
        out:(hlreg)reg = op.I (left:(hlreg)reg, right:(bcreg)reg)       \
            with %out == %left                                          \
            emit "call " helper "3"                                     \
            cost 4;                                                     \
        out:(hlhlreg)reg = op.L (left:(hlhlreg)reg, right:(bcbcreg)reg) \
            with %out == %left, corrupted(bcbcreg)                      \
            emit "call " helper "6"                                     \
            cost 4;                                                     \
            

    ALUOP(LSL, ".sli");
    ALUOP(LSR, ".sru");
    ALUOP(ASR, ".sri");
    ALUOP(AND, ".and");
    ALUOP(OR, ".ior");
    ALUOP(EOR, ".xor");




/* Long arithmetic */

    out:(hlhlreg)reg = SUB.L(left:(hlhlreg)reg, right:(long)reg)
        with %out == %left
        emit "and a"
        emit "sbc %out, %right"
        emit "exx"
        emit "sbc %out, %right"
        emit "exx"
        cost 12;

    out:(hlhlreg)reg = ADD.L(left:(hlhlreg)reg, right:(long)reg)
        with %out == %left
        emit "add %out, %right"
        emit "exx"
        emit "adc %out, %right"
        emit "exx"
        cost 12;

    out:(hlhlreg)reg = NEG.L(left:(long)reg)
        with preserved(%left)
        emit "ld %out, 0"
        emit "push %out"
        emit "and a"
        emit "sbc %out, %left"
        emit "exx"
        emit "pop %out"
        emit "sbc %out, %left"
        emit "exx"
        cost 13;

    out:(dedereg)reg = DIV.L(left:(dedereg)reg, right:(bcbcreg)reg)
        emit "call .rmsdvs6"
        cost 14;

    out:(hlhlreg)reg = MOD.L(left:(dedereg)reg, right:(bcbcreg)reg)
        emit "call .rmsdvs6"
        cost 14;

    out:(dedereg)reg = DIVU.L(left:(dedereg)reg, right:(bcbcreg)reg)
        emit "call .rmudvu6"
        cost 14;

    out:(hlhlreg)reg = MODU.L(left:(dedereg)reg, right:(bcbcreg)reg)
        emit "call .rmudvu6"
        cost 14;

    out:(hlhlreg)reg = MUL.L(left:(bcbcreg)reg, right:(dedereg)reg)
        emit "call .mli6"
        cost 14;

    out:(hlhlreg)reg = FROMSI.L(left:(hlreg)reg)
        emit "call .extendw"
        cost 12;

    out:(long)reg = FROMSL.L(left:(long)reg)
        with %out == %left
        cost 1;

    out:(long)reg = FROMUL.L(left:(long)reg)
        with %out == %left
        cost 1;

    out:(long)reg = FROMUI.L(left:(int)reg)
        emit "push %left"
        emit "pop %out"
        emit "exx"
        emit "ld %out, 0"
        emit "exx"
        cost 5;
    
    out:(long)reg = FROMIPAIR.L(hi:(int)reg, lo:(int)reg)
        with preserved(%lo)
        emit "push %hi"
        emit "exx"
        emit "pop %out"
        emit "exx"
        emit "push %lo"
        emit "pop %out"
        cost 5;

    out:(int)reg = FROML0.I(left:(long)reg)
        emit "push %left"
        emit "pop %out"
        cost 5;

    out:(int)reg = FROML1.I(left:(long)reg)
        emit "exx"
        emit "push %left"
        emit "exx"
        emit "pop %out"
        cost 5;

/* Float arithmetic */

    out:(float)reg = value:CONST.F
        emit "call .float_unsupported"
        cost 5;

    out:(float)reg = NOP.F(in:(float)reg)
        with %out == %in
        cost 1;

    out:(float)reg = COPYI.F(in:(int)reg)
        emit "push %in"
        emit "pop %out"
        cost 5;

    out:(int)reg = COPYF.I(in:(float)reg)
        emit "push %in"
        emit "pop %out"
        cost 5;

    out:(int)reg = COMPAREF.I(left:(float)reg, right:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = ADDF.F(left:(float)reg, right:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = SUBF.F(left:(float)reg, right:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = MULF.F(left:(float)reg, right:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = DIVF.F(left:(float)reg, right:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = NEGF.F(in:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(int)reg = FROMSF.I(in:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(int)reg = FROMUF.I(in:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(long)reg = FROMUF.L(in:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(long)reg = FROMSF.L(in:(float)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = FROMSL.F(in:(long)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = FROMUL.F(in:(long)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = FROMSI.F(in:(int)reg)
        emit "call .float_unsupported"
        cost 10;

    out:(float)reg = FROMUI.F(in:(int)reg)
        emit "call .float_unsupported"
        cost 10;



/* Comparisons */

    out:(hlreg)flags = COMPARESI.I(left:(hlreg)reg, right:(basereg)reg)
        emit "and a"
        emit "sbc %left, %right"
        emit "call .signedcmp"
        ;

    out:(hlreg)flags = COMPARESL.I(left:(hlhlreg)reg, right:(long)reg)
        emit "and a"
        emit "sbc %left, %right"
        emit "exx"
        emit "sbc %left, %right"
        emit "exx"
        emit "call .signedcmp"
        ;

    out:(hlreg)flags = COMPAREUI.I(left:(hlreg)reg, right:(basereg)reg)
        emit "and a"
        emit "sbc %left, %right"
        ;

    out:(hlreg)flags = COMPAREUL.I(left:(hlhlreg)reg, right:(long)reg)
        emit "and a"
        emit "sbc %left, %right"
        emit "exx"
        emit "sbc %left, %right"
        emit "exx"
        ;

    out:(hlreg)flags = COMPAREF.I(left:(float)reg, right:(float)reg)
        emit "call .float_unsupported"
        ;

    CJUMPLT(flags:(int)flags, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "jp c, $true"
        emit "jp $false"
        ;

    CJUMPLE(flags:(int)flags, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "jp c, $true"
        emit "jp z, $true"
        emit "jp $false"
        ;

    CJUMPEQ(flags:(int)flags, PAIR(true:BLOCK.I, false:BLOCK.I))
        emit "jp z, $true"
        emit "jp $false"
        ;

    out:(basereg)reg = IFEQ.I(flags:(int)flags)
        emit "ld %out, 0"
        emit "jr nz, 1f"
        emit "inc %out"
        emit "1:"
        cost 15;

    out:(basereg)reg = IFLT.I(flags:(int)flags)
        emit "ld %out, 0"
        emit "jp c, 1f"
        emit "inc %out"
        emit "1:"
        cost 15;

    out:(basereg)reg = IFLE.I(flags:(int)flags)
        emit "ld %out, 0"
        emit "jp z, 1f"
        emit "jp c, 1f"
        emit "inc %out"
        emit "1:"
        cost 15;

/* Jumps and calls */

    JUMP(in:BLOCK.I)
        emit "jp $in"
        cost 10;

    JUMP(in:(hlreg)reg)
        emit "jp (hl)"
        cost 10;

    #define CALLLABEL(insn) \
        insn (dest:LABEL.I) \
            with corrupted(volatile) \
            emit "call $dest" \
            cost 10;

    CALLLABEL(CALL)
    out:(iret)reg = CALLLABEL(CALL.I)
    out:(lret)reg = CALLLABEL(CALL.L)

    #define CALLINDIRECT(insn) \
        insn (dest:(hlreg)reg) \
            with corrupted(volatile) \
            emit "call .pchl" \
            cost 10;

    CALLINDIRECT(CALL)
    out:(iret)reg = CALLINDIRECT(CALL.I);
    out:(lret)reg = CALLINDIRECT(CALL.L);
        
/* vim: set sw=4 ts=4 expandtab : */

