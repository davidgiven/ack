EM_WSIZE = 3  /* size of a word */
EM_PSIZE = 3  /* size of a pointer */
EM_BSIZE = 6  /* two pointers saved in stack frame */

FP_OFFSET = 0 /* offset of saved FP relative to our FP */
PC_OFFSET = 3 /* offset of saved PC relative to our PC */

#define COMMENT(n) /* command {LABEL, n} */

PROPERTIES

    areg        /* the A register */
    breg        /* any byte-sized register */

    hlreg       /* the HL register */
    bcreg       /* the BC register */
    dereg       /* the DE register */
    hlbcdereg   /* any of HL, BC, DE */
    xreg        /* any index register */
    wreg        /* any word-sized register */
    spreg       /* the stack pointer */

REGISTERS

    a:                  areg, breg.
    b, c, d, e, h, l:   breg.
    hl("hl")=h+l:       hlreg, hlbcdereg, wreg.
    bc("bc")=b+c:       bcreg, hlbcdereg, wreg.
    de("de")=d+e:       dereg, hlbcdereg, wreg.
    ix:                 wreg, xreg.
    sp:                 spreg.

TOKENS

    const1      = { INT num; } 1 num.
    const3      = { INT num; } 3 num.
    label       = { ADDR off; } 3 off.
    comment     = { ADDR str; } 0 "! " str.

    memref      = { ADDR off; } 2 "(" off ")".
    stackaddr   = { ADDR off; } 3 "iy+" off .
    stackref    = { ADDR off; } 2 "(iy+" off ")".

SETS

    
    bc_de       = bcreg + dereg.
    hl_de       = hlreg + dereg.
    any_reg     = breg + wreg.

INSTRUCTIONS

    add areg:rw, breg+const1:ro.
    add hlreg:rw, spreg:ro.
    Call "call" label:ro.
    ex spreg, hlreg:rw.
    dec breg+wreg+spreg:rw.
    inc breg+wreg+spreg:rw.
    jp label:ro.
    ld breg:wo, (breg+const1):ro.
    ld breg:wo, memref:ro.
    ld wreg:wo, const3+label:ro.
    ld wreg:wo, memref:ro.
    ld breg+wreg:wo, stackref:ro.
    ld spreg:wo, hlreg:ro.
    ld memref:wo, hlbcdereg:ro.
    lea hlbcdereg:wo, stackaddr:ro.
    pop wreg:wo.
    push wreg:ro.
    xor breg:ro.


MOVES

    from breg to breg
        gen
            ld %2, %1

    from const1 %num==0 to areg
        gen
            xor a

    from const1 to breg
        gen
            ld %2, %1

    from const3 to wreg
        gen
            ld %2, %1

    from label to wreg
        gen
            ld %2, %1

    from hlbcdereg to hlbcdereg
        gen
            ld %2.1, %1.1
            ld %2.2, %1.2

STACKINGRULES

    from wreg to STACK
        gen
            push %1

    from const3+hlbcdereg+label to STACK
        uses hlbcdereg
        gen
            move %1, %a
            push %a

    from const3+hlbcdereg+label to STACK
        gen
            push hl
            move %1, hl
            ex sp, hl

COERCIONS

   from STACK
        uses wreg
        gen
            pop %a
        yields %a

PATTERNS

/* Stack stuff */

    pat asp $1==0 /* do nothing */

    pat asp ($1==1)
        with STACK
        gen
            inc sp

    pat asp ($1==0-1)
        with STACK
        gen
            dec sp

    pat asp ($1==3)
        with STACK
        uses wreg
        gen
            pop %a
           
    pat asp
        with STACK
        uses hlreg={const3, $1}
        gen
            add hl, sp
            ld sp, hl

    pat loc
        yields {const3, $1}

/* Conversions */

    pat loc loc cuu
        leaving
            loc $1
            loc $2
            cuu

    pat loc loc cui
        leaving
            loc $1
            loc $2
            cuu

    pat cui
        leaving
            cuu $1

    pat ciu
        leaving
            cuu $1

    pat loc loc cuu $1==$2
    
    pat loc loc cuu $1==3 && $2==6
        with wreg+const3+label
        yields {const3, 0} %1

/* Loads and saves */

    pat lal
        uses hlbcdereg
        gen
            lea %a, {stackaddr, $1}
        yields %a

    pat lol
        uses hlbcdereg
        gen
            ld %a, {stackref, $1}
        yields %a

    pat stl lol $1==$2
        with wreg
        yields
            %1 %1
        leaving
            stl $1

    pat stl
        with hlbcdereg
        gen
            ld {memref, $1}, %1

    pat lae
        uses wreg
        gen
            ld %a, {label, $1}
        yields %a

    pat loe
        uses wreg
        gen
            ld %a, {memref, $1}
        yields %a
        
/* Subroutines and jumps */

    pat cal
        kills ALL
        gen
            Call {label, $1}

    pat cai
        with hlreg
        kills ALL
        gen
            Call {label, ".pchl"}

    pat ret $1==0
        with STACK
        gen
            jp {label, ".ret"}

    pat ret $1==3
        with STACK
        uses hlreg
        gen
            jp {label, ".ret"}

// vim: sw=4 ts=4 et

