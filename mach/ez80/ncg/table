EM_WSIZE = 3  /* size of a word */
EM_PSIZE = 3  /* size of a pointer */
EM_BSIZE = 6  /* two pointers saved in stack frame */

FP_OFFSET = 0 /* offset of saved FP relative to our FP */
PC_OFFSET = 3 /* offset of saved PC relative to our PC */

#define COMMENT(n) /* command {LABEL, n} */

PROPERTIES

    areg        /* the A register */
    breg        /* any byte-sized register */

    hlreg       /* the HL register */
    bcreg       /* the BC register */
    dereg       /* the DE register */
    hlbcdereg   /* any of HL, BC, DE */
    xreg        /* any index register */
    wreg        /* any word-sized register */
    spreg       /* the stack pointer */

REGISTERS

    a:                          areg, breg.
    b, c, d, e, h, l, ixh, ixl: breg.
    hl("hl")=l+h:               hlreg, hlbcdereg, wreg.
    bc("bc")=c+b:               bcreg, hlbcdereg, wreg.
    de("de")=e+d:               dereg, hlbcdereg, wreg.
    ix("ix")=ixl+ixh:           wreg, xreg.
    sp:                         spreg.

TOKENS

    const1      = { INT num; } 1 num.
    const3      = { INT num; } 3 num.
    label       = { ADDR off; } 3 off.
    comment     = { ADDR str; } 0 "! " str.

    regind      = { wreg reg; } 2 "(" reg ")".
    memref      = { ADDR off; } 2 "(" off ")".
    stackaddr   = { ADDR off; } 3 "iy+" off .
    stackref    = { ADDR off; } 2 "(iy+" off ")".

SETS

    
    bc_de       = bcreg + dereg.
    hl_de       = hlreg + dereg.
    any_reg     = breg + wreg.
    any         = any_reg + const3 + label.

INSTRUCTIONS

    Call "call" label:ro.
    add areg:rw, breg+const1:ro.
    add hlreg:rw, spreg:ro.
    and areg:rw, const1+breg:ro.
    dec breg+wreg+spreg:rw.
    ex spreg, hlreg:rw.
    inc breg+wreg+spreg:rw.
    jp label:ro.
    jpz label:ro.
    jpnz label:ro.
    ld breg+wreg:wo, stackref:ro.
    ld breg:wo, (breg+const1):ro.
    ld breg:wo, memref+regind:ro.
    ld memref:wo, wreg:ro.
    ld spreg:wo, hlreg:ro.
    ld wreg:wo, const1+const3+label:ro.
    ld wreg:wo, memref+regind:ro.
    lea hlbcdereg:wo, stackaddr:ro.
    pea stackaddr:ro.
    pop wreg:wo.
    push wreg:ro.
    sbc hlreg:rw, hlbcdereg+spreg:ro.
    xor breg:ro.


MOVES

    from const1 %num==0 to areg
        gen
            xor a

    from const1+breg to breg
        gen
            ld %2, %1

    from breg to wreg
        gen
            move %1, %2.1
            move {const1, 0}, %2.2

    from const1+const3 to wreg
        gen
            ld %2, %1

    from label to wreg
        gen
            ld %2, %1

    from wreg to wreg
        gen
            push %1
            pop %2

STACKINGRULES

    from wreg to STACK
        gen
            push %1

    from const3+hlbcdereg+label to STACK
        uses hlbcdereg
        gen
            move %1, %a
            push %a

    from const3+hlbcdereg+label to STACK
        gen
            push hl
            move %1, hl
            ex sp, hl

    from const1+breg to STACK
        uses hlbcdereg
        gen
            move %1, %a
            push %a

    from const1+breg to STACK
        gen
            push hl
            move %1, hl
            ex sp, hl

    from stackaddr to STACK
        gen
            pea %1

COERCIONS

   from STACK
        uses wreg
        gen
            pop %a
        yields %a

PATTERNS

/* Stack stuff */

    pat dup $1==3
        with any
        yields %1 %1

    pat dup $1==6
        with any any
        yields %2 %1 %2 %1

    pat asp $1==0 /* do nothing */

    pat asp ($1==1)
        with STACK
        gen
            inc sp

    pat asp ($1==0-1)
        with STACK
        gen
            dec sp

    pat asp ($1==3)
        with STACK
        uses wreg
        gen
            pop %a
           
    pat asp
        with STACK
        uses hlreg={const3, $1}
        gen
            add hl, sp
            ld sp, hl

    pat loc
        yields {const3, $1}

/* Conversions */

    pat loc loc cuu
        leaving
            loc $1
            loc $2
            cuu

    pat loc loc cui
        leaving
            loc $1
            loc $2
            cuu

    pat cui
        leaving
            cuu $1

    pat ciu
        leaving
            cuu $1

    pat loc loc cuu $1==$2
    
    pat loc loc cuu $1==3 && $2==6
        with wreg+const3+label
        yields {const3, 0} %1

    pat loc loc cuu $1==6 && $2==3
        with wreg wreg
        yields %2

/* Loads and saves */

    pat lal
        yields {stackaddr, $1}

    pat loi $1==3
        with exact label
            uses wreg
            gen
                ld %a, {memref, %1.off}
            yields %a
        with stackaddr
            uses hlbcdereg
            gen
                ld %a, {stackref, %1.off}
            yields %a
        with wreg
            uses wreg
            gen
                ld %a, {regind, %1}

    pat loi $1==6
        with wreg
            uses wreg, wreg
            gen
                ld %a, {regind, %1}
                inc %1
                inc %1
                inc %1
                ld %b, {regind, %1}
        
    pat lol
        leaving
            lal $1
            loi 3

    pat stl lol $1==$2
        with wreg
        yields
            %1 %1
        leaving
            stl $1

    pat stl
        leaving
            lal $1
            sti 3

    pat ldl
        leaving
            lal $1
            loi 6

    pat sdl
        leaving
            lal $1
            sti 6

    pat lae
        yields {label, $1}

    pat loe
        leaving
            lae $1
            loi 3

    pat lde
        leaving
            lae $1
            loi 6

    pat ste
        leaving
            lae $1
            sti 3
        
    pat sde
        leaving
            lae $1
            sti 6
        
/* Arithmetic */

    pat dec
        with wreg
        gen
            dec %1
        yields %1

    pat inc
        with wreg
        gen
            inc %1
        yields %1

    pat ngi $1==3
        leaving
            loc 0
            xcg 3
            sbi 3
        
    pat ngi $1==6
        leaving
            loc 0
            loc 0
            xcg 6
            sbi 6
        
    pat ngi $1==6
        with bcreg+dereg
        uses hlreg={const3, 0}
        gen
            and a, a
            sbc %a, %1
        yields %a
        
/* Subroutines and jumps */

    pat cal
        kills ALL
        gen
            Call {label, $1}

    pat cai
        with hlreg
        kills ALL
        gen
            Call {label, ".pchl"}

    pat ret $1==0
        with STACK
        gen
            jp {label, ".ret"}

    pat ret $1==3
        with STACK
        uses hlreg
        gen
            jp {label, ".ret"}

    pat lfr $1==3
        yields hl

/* Comparisons */

    pat cmi $1==3
        leaving
            sbi 3

    pat cmu $1==3
        leaving
            sbu 3

    pat cmi $1==6
        with STACK
        gen
            Call {label, ".cmi6"}
        yields hl

    pat cmu $1==6
        with STACK
        gen
            Call {label, ".cmu6"}
        yields hl

/* Branches */

    pat bra
        with STACK
        gen
            jp {label, $1}

    pat bne
        with hlbcdereg hlreg STACK
        gen
            and a, a
            sbc %2, %1
            jpnz {label, $1}
        with hlreg wreg STACK
        leaving
            exg 2
            bne $1
            
    pat beq
        with hlbcdereg hlreg STACK
        gen
            and a, a
            sbc %2, %1
            jpz {label, $1}
        with hlreg wreg STACK
        leaving
            exg 2
            beq $1
            
    pat zlt
        with 


/* Weird miscellaneous stuff */

    pat lin
        uses hlbcdereg={const3, $1}
        gen
            ld {memref, ".hol0"}, %a

    pat lni
        uses hlbcdereg
        gen
            ld %a, {memref, ".hol0"}
            inc %a
            ld {memref, ".hol0"}, %a


// vim: sw=4 ts=4 et

