EM_WSIZE = 3  /* size of a word */
EM_PSIZE = 3  /* size of a pointer */
EM_BSIZE = 6  /* two pointers saved in stack frame */

FP_OFFSET = 0 /* offset of saved FP relative to our FP */
PC_OFFSET = 3 /* offset of saved PC relative to our PC */

#define COMMENT(n) /* command {LABEL, n} */

PROPERTIES

    areg        /* the A register */
    breg        /* any byte-sized register */

    hlreg       /* the HL register */
    hlhlreg     /* the HLHL' register */
    bcreg       /* the BC register */
    dereg       /* the DE register */
    dedereg     /* the DEDE' register */
    xreg        /* IX */
    xxreg       /* IX or iy */
    wreg        /* any word-sized register except IX */
    wxreg       /* any word-sized register including IX */
    dreg        /* any doubleword-sized register */
    spreg       /* the stack pointer */
    fpreg       /* the frame pointer */
    afreg       /* AF */
    altreg      /* alternate bank registers */
    hlreg_or_dereg /* HL or DE */

REGISTERS

    a:                          areg, breg.
    b, c, d, e, h, l, ixh, ixl: breg.
    hl("hl")=l+h:               hlreg, wreg, wxreg, hlreg_or_dereg.
    bc("bc")=c+b:               bcreg, wreg, wxreg.
    de("de")=e+d:               dereg, wreg, wxreg, hlreg_or_dereg.
    ix("ix")=ixl+ixh:           xreg, wxreg, xxreg.
    iy:                         fpreg, xxreg.
    sp:                         spreg.
    af:                         afreg.

    hlhl("hl")=hl:              dreg, hlhlreg.
    bcbc("bc")=bc:              dreg.
    dede("de")=de:              dreg, dedereg.

TOKENS

    const1      = { INT num; } 1 num.
    const3      = { INT num; } 3 num.
    label       = { ADDR off; } 3 off.
    comment     = { ADDR str; } 0 "! " str.

    regind      = { wreg reg; } 3 "(" reg ")".
    indexref1   = { xxreg reg; ADDR off; } 1 "(" reg "+" off ")".
    indexref3   = { xxreg reg; ADDR off; } 3 "(" reg "+" off ")".
    indexref6   = { xxreg reg; ADDR off; } 6 "(" reg "+" off ")".
    memref1     = { ADDR off; } 1 "(" off ")".
    memref3     = { ADDR off; } 3 "(" off ")".
    memref6     = { ADDR off; } 6 "(" off ")".
    stackaddr   = { ADDR off; } 3 "iy+" off .

SETS

    
    bc_de       = bcreg + dereg.
    hl_de       = hlreg + dereg.
    any_reg     = breg + wreg.
    any_int     = any_reg + const3 + label.
    any_long    = dreg.

INSTRUCTIONS

    Call "call" label:ro kills :cc.
    adc hlreg+hlhlreg:rw, wreg:ro kills :cc.
    add areg:rw, breg+const1:ro kills :cc.
    add hlreg+hlhlreg:rw, wreg:ro kills :cc.
    add hlreg:rw, spreg:ro kills :cc.
    and const1+breg:ro.
    dec breg+wreg+spreg:rw:cc.
    ex dereg:rw, hlreg:rw.
    exsp "ex (sp)," hlreg:rw.
    exx.
    inc breg+wreg+spreg:rw:cc.
    jp label+regind:ro kills :cc.
    jpc "jp c," label:ro kills :cc.
    jpm "jp m," label:ro kills :cc.
    jpnc "jp nc," label:ro kills :cc.
    jpnz "jp nz," label:ro kills :cc.
    jpp "jp p," label:ro kills :cc.
    jpz "jp z," label:ro kills :cc.
    jr label:ro kills :cc.
    jrc "jp z," label:ro kills :cc.
    jrm "jp m," label:ro kills :cc.
    jrnc "jp nc," label:ro kills :cc.
    jrnz "jp nz," label:ro kills :cc.
    jrp "jp p," label:ro kills :cc.
    jrz "jp z," label:ro kills :cc.
    ld areg:wo, memref1:ro.
    ld breg:wo, breg+const1+indexref1+regind:ro.
    ld breg+memref1+indexref1+regind:wo, breg:ro.
    ld memref3+indexref3:wo, wreg:ro.
    ld regind:wo, wreg:ro.
    ld spreg:wo, hlreg+memref3:ro.
    ld wreg:wo, memref3+indexref3:ro.
    ld wxreg+fpreg:wo, const1+const3+label+memref3+indexref3+regind:ro.
    ldir kills :cc.
    lea wxreg:wo:cc, stackaddr:ro.
    pea stackaddr:ro.
    pop wreg+xreg+afreg:wo.
    push wreg+xreg+afreg:ro.
    sbc hlreg+hlhlreg:rw:cc, wreg+spreg:ro.
    xor breg:ro:cc.


MOVES

    from const1 %num==0 to areg
        gen
            xor a

    from const1+breg to breg
        gen
            ld %2, %1

    from breg to wreg
        gen
            move %1, %2.1
            move {const1, 0}, %2.2

    from const1+const3 to wreg
        gen
            ld %2, %1

    from const1+const3 to dreg
        gen
            move %1, %2.1
            exx.
            move {const1, 0}, %2.1
            exx.

    from label to wreg
        gen
            ld %2, %1

    from label to xreg
        gen
            ld %2, %1

    from indexref3 to wxreg
        gen
            ld %2, %1

    from wxreg to wxreg
        gen
            push %1
            pop %2

    from areg to wreg
        gen
            ld %2, {const3, 0}
            ld %2.1, %1


TESTS

    to test hlreg
        gen
            Call {label, ".testhl3"}
            
    to test bcreg
        gen
            Call {label, ".testbc3"}
            
    to test dereg
        gen
            Call {label, ".testde3"}
            
STACKINGRULES

    from wreg+xreg to STACK
        gen
            push %1

    from dreg to STACK
        gen
            exx.
            push %1.1
            exx.
            push %1.1

    from const3+wreg+label to STACK
        uses wreg
        gen
            move %1, %a
            push %a

    from const3+wreg+label to STACK
        gen
            push hl
            move %1, hl
            exsp hl

    from const1+breg to STACK
        uses wreg
        gen
            move %1, %a
            push %a

    from const1+breg to STACK
        gen
            push hl
            move %1, hl
            exsp hl

    from stackaddr to STACK
        gen
            pea %1

    from memref1 to STACK
        gen
            push hl
            ld hl, {const3, 0}
            push af
            ld a, %1
            ld l, a
            pop af
            exsp hl

    from indexref1 to STACK
        gen
            push hl
            ld l, %1
            exsp hl

    from memref3 to STACK
        gen
            push hl
            ld hl, %1
            exsp hl

    from indexref3 to STACK
        gen
            push hl
            ld hl, %1
            exsp hl

    from memref6 to STACK
        gen
            push hl
            ld hl, {memref3, %1.off+0}
            exsp hl
            push hl
            ld hl, {memref3, %1.off+3}
            exsp hl

    from indexref6 to STACK
        gen
            push hl
            ld hl, {indexref3, %1.reg, %1.off+0}
            exsp hl
            push hl
            ld hl, {indexref3, %1.reg, %1.off+3}
            exsp hl

COERCIONS

    from STACK
        uses wxreg
        gen
            pop %a
        yields %a

    from STACK
        uses dreg
        gen
            pop %a.1
            exx.
            pop %a.1
            exx.
        yields %a
    
    from breg
        uses wreg={const3, 0}
        gen
            ld %a.1, %1
        yields %a

    from hlreg_or_dereg
        uses hlreg_or_dereg
        gen
            ex de, hl
        yields %a

    from stackaddr
        uses wxreg
        gen
            lea %a, %1
        yields %a

    from indexref3
        uses wxreg
        gen
            ld %a, %1
        yields %a

    from label+const1+const3
        uses wxreg
        gen
            ld %a, %1
        yields %a

    from indexref6
        uses dreg
        gen
            ld %a.1, {indexref3, %1.reg, %1.off+0}
            exx.
            ld %a.1, {indexref3, %1.reg, %1.off+3}
            exx.
        yields %a

    from wxreg
        uses wxreg
        gen
            push %1
            pop %a
        yields %a

PATTERNS

/* Stack stuff */

    pat dup $1==3
        with any_int
        yields %1 %1

    pat dup $1==6
        with any_long
        yields %1 %1

    pat exg $1==3
        with any_int any_int
        yields %1 %2

    pat exg $1==6
        with any_long any_long
        yields %1 %2

    pat asp $1==0 /* do nothing */

    pat asp $1==1
        with STACK
        gen
            inc sp

    pat asp $1==0-1
        with STACK
        gen
            dec sp

    pat asp $1==3
        with STACK
        uses wreg
        gen
            pop %a
           
    pat asp
        with STACK
        uses hlreg={const3, $1}
        gen
            add hl, sp
            ld sp, hl

    pat loc
        yields {const3, $1}

    pat lpi
        leaving
            loc $1

/* Conversions */

    pat loc loc ciu
        leaving
            loc $1
            loc $2
            cuu

    pat loc loc cui
        leaving
            loc $1
            loc $2
            cuu

    pat cui
        leaving
            cuu $1

    pat ciu
        leaving
            cuu $1

    pat loc loc cuu $1==$2
    pat loc loc cii $1==$2
    
    pat loc loc cii $1>$2
        leaving
            loc $1
            loc $2
            cuu

    pat loc loc cuu $1==1 && $2==3
        with wreg
        uses wreg={const3, 0}
        gen
            ld %a.1, %1.1
        yields %a

    pat loc loc cuu $1==3 && $2==6
        with wreg+const3+label
        yields {const3, 0} %1

    pat loc loc cuu $1==6 && $2==3
        with dreg
        yields %1.1

    pat loc loc cii $1==1 && $2==3
        with wreg
            uses areg
            gen
                ld %a, %1.1
                Call {label, ".cii13"}
            yields hl
        with areg
            gen
                Call {label, ".cii13"}
            yields hl

    pat loc loc cii $1==3 && $2==6
        with hlreg dereg
        gen
            Call {label, ".cii36"}
        yields hlhl

/* Loads and saves */

    pat lal
        yields {stackaddr, $1}

    pat loi $1==1
        with label
            yields {memref1, %1.off}
        with stackaddr
            yields {indexref1, iy, %1.off}
        with hlreg
            uses wreg={const3, 0}
            gen
                ld %a.1, {regind, %1}
            yields %a
        #if 0
        with wreg
            uses areg
            gen
                ld %a, {regind, %1}
            yields %a
       #endif

    pat loi $1==3
        with label
            yields {memref3, %1.off}
        with stackaddr
            yields {indexref3, iy, %1.off}
        with hlreg
            uses wreg
            gen
                ld %a, {regind, %1}
            yields %a
        with xreg
            yields {indexref3, %1, 0}

    pat loi $1==6
        with exact label
            yields {memref6, %1.off}
        with stackaddr
            yields {indexref6, iy, %1.off}
        with xreg
            yields {indexref6, %1, 0}
        
    pat loi
        with hlreg STACK
            uses areg={const1, $1}
            gen
                Call {label, ".loi"}

    pat sti $1==1
        with label areg
            gen
                ld {memref1, %1.off}, %2
        with stackaddr areg
            gen
                ld {indexref1, iy, %1.off}, %2
        with hlreg wreg
            gen
                ld {regind, %1}, %2.1
        with wreg areg
            gen
                ld {regind, %1}, %2
        with xxreg areg
            gen
                ld {indexref1, %1, 0}, %2

    pat sti $1==3
        with label wreg
            gen
                ld {memref3, %1.off}, %2
        with stackaddr wreg
            gen
                ld {indexref3, iy, %1.off}, %2
        with hlreg wreg
            gen
                ld {regind, %1}, %2

    pat sti $1==6
        with label dreg
            gen
                ld {memref3, %1.off+0}, %2.1
                exx.
                ld {memref3, %1.off+3}, %2.1
                exx.
        with stackaddr dreg
            gen
                ld {indexref3, iy, %1.off+0}, %2.1
                exx.
                ld {indexref3, iy, %1.off+3}, %2.1
                exx.
        with xreg dreg
            gen
                ld {indexref3, %1, 0}, %2.1
                exx.
                ld {indexref3, %1, 3}, %2.1
                exx.

    pat sti
        with hlreg STACK
        uses areg={const1, $1}
            gen
                Call {label, ".sti"}

    pat lol
        leaving
            lal $1
            loi 3

    pat lil
        leaving
            lol $1
            loi 3

    pat sil
        leaving
            lol $1
            sti 3

    pat stl lol $1==$2
        with wreg
        yields
            %1 %1
        leaving
            stl $1

    pat stl
        leaving
            lal $1
            sti 3

    pat ldl
        leaving
            lal $1
            loi 6

    pat sdl
        leaving
            lal $1
            sti 6

    pat lae
        yields {label, $1}

    pat loe
        leaving
            lae $1
            loi 3

    pat lof
        leaving
            adp $1
            loi 3

    pat lde
        leaving
            lae $1
            loi 6

    pat ste
        leaving
            lae $1
            sti 3
        
    pat sde
        leaving
            lae $1
            sti 6
        
    pat inl
        leaving
            lol $1
            inc
            stl $1

    pat del
        leaving
            lol $1
            dec
            stl $1

    pat ine
        leaving
            lae $1
            dup 3
            loi 3
            inc
            exg 3
            sti 3

    pat dee
        leaving
            lae $1
            dup 3
            loi 3
            dec
            exg 3
            sti 3

    pat zrl
        leaving
            loc 0
            stl $1

    pat zre
        leaving
            loc 0
            ste $1

/* Arithmetic */

    pat adp
        leaving
            loc $1
            adi 3

    pat dec
        with wreg
        gen
            dec %1
        yields %1

    pat inc
        with wreg
        gen
            inc %1
        yields %1

    pat adu
        leaving
            adi $1

    pat ads
        leaving
            adi $1

    pat sbs
        leaving
            sbi $1

    pat adi $1==3
        with hlreg wreg
            gen
                add %1, %2
            yields %1
        with wreg hlreg
            leaving
                exg 3
                adi 3

    pat adi $1==6
        with hlhlreg dreg
            gen
                add %1.1, %2.1
                exx.
                adc %1.1, %2.1
                exx.
            yields %1
        with dreg hlhlreg
            leaving
                exg 6
                adi 6

    pat sbu
        leaving
            sbi $1

    pat sbi $1==3
        with wreg hlreg
            gen
                and a
                sbc %2, %1
            yields %1

    pat sbi $1==6
        with dreg hlhlreg
        gen
            and a
            sbc %2.1, %1.1
            exx.
            sbc %2.1, %1.1
            exx.
        yields %1

    pat mlu
        leaving
            mli $1

    pat mli $1==3
        with hlreg dereg
        kills ALL
        gen
            Call {label, ".mli3"}
        yields
            hl

    pat mli $1==6
        with hlhlreg dedereg
        kills ALL
        gen
            Call {label, ".mli6"}
        yields
            hlhl

    pat rmi $1==3
        with hlreg dereg
        kills ALL
        gen
            Call {label, ".rmidvi3"}
        yields
            de

    pat dvi $1==3
        with hlreg dereg
        kills ALL
        gen
            Call {label, ".rmidvi3"}
        yields
            hl

    pat rmu $1==3
        with hlreg dereg
        kills ALL
        gen
            Call {label, ".rmudvu3"}
        yields
            de

    pat dvu $1==3
        with hlreg dereg
        kills ALL
        gen
            Call {label, ".rmudvu3"}
        yields
            hl

    pat rmi $1==6
        with hlhlreg dedereg
        kills ALL
        gen
            Call {label, ".rmidvi6"}
        yields
            dede

    pat dvi $1==6
        with hlhlreg dedereg
        kills ALL
        gen
            Call {label, ".rmidvi6"}
        yields
            hlhl

    pat rmu $1==6
        with hlhlreg dedereg
        kills ALL
        gen
            Call {label, ".rmudvu6"}
        yields
            dede

    pat dvu $1==6
        with hlhlreg dedereg
        kills ALL
        gen
            Call {label, ".rmudvu6"}
        yields
            hlhl

    pat ngi $1==3
        leaving
            loc 0
            exg 3
            sbi 3
        
    pat ngi $1==6
        leaving
            loc 0
            loc 0
            exg 6
            sbi 6
        
    pat slu
        leaving
            sli $1

    pat loc sli $1==0

    pat loc sli $1!=0
        leaving
            adi $2
            loc $1-1
            sli $2

    pat sli $1==3
        with dereg hlreg
        kills ALL
        gen
            Call {label, ".sli3"}
        yields hl
        
    pat sli $1==6
        with dereg hlhlreg
        kills ALL
        gen
            Call {label, ".sli6"}
        yields hlhl
        
    pat sru
        leaving
            sri $1

    pat loc sri $1==0

    pat sri $1==3
        with dereg hlreg
        kills ALL
        gen
            Call {label, ".sri3"}
        yields hl
        
    pat sri $1==6
        with dereg hlhlreg
        kills ALL
        gen
            Call {label, ".sri6"}
        yields hlhl
        
/* Logical operations */

    pat and $1==3
        with STACK
        kills ALL
        gen
            Call {label, ".and3"}
        yields hl

    pat and $1==6
        with STACK
        kills ALL
        gen
            Call {label, ".and6"}
        yields hl

    pat ior $1==3
        with STACK
        kills ALL
        gen
            Call {label, ".ior3"}
        yields hl

    pat ior $1==6
        with STACK
        kills ALL
        gen
            Call {label, ".ior6"}
        yields hl

    pat xor $1==3
        with STACK
        kills ALL
        gen
            Call {label, ".xor3"}
        yields hl

    pat xor $1==6
        with STACK
        kills ALL
        gen
            Call {label, ".xor6"}
        yields hl

    pat com $1==3
        with STACK
        kills ALL
        gen
            Call {label, ".com3"}
        yields hl

    pat com $1==6
        with STACK
        kills ALL
        gen
            Call {label, ".com6"}
        yields hl

/* Floating point arithmetic */

    proc floatop example cmf
        gen
            Call {label, ".float_unsupported"}

    pat adf call floatop("adf")
    pat cfi call floatop("cfi")
    pat cfu call floatop("cfu")
    pat cif call floatop("cif")
    pat cuf call floatop("cuf")
    pat cmf call floatop("cmf")
    pat dvf call floatop("dvf")
    pat fef call floatop("fef")
    pat fif call floatop("fif")
    pat mlf call floatop("mlf")
    pat ngf call floatop("ngf")
    pat sbf call floatop("sbf")
    pat stf call floatop("stf")
    pat ldf call floatop("ldf")
    pat sdf call floatop("sdf")

/* Subroutines and jumps */

    pat cal
        kills ALL
        gen
            Call {label, $1}

    pat cai
        with hlreg
        kills ALL
        gen
            Call {label, ".pchl"}

    pat ret $1==0
        with STACK
        gen
            jp {label, ".ret"}

    pat ret $1==3
        with dereg STACK
        gen
            jp {label, ".ret"}

    pat ret $1==6
        with dedereg STACK
        gen
            jp {label, ".ret"}

    pat lfr $1==3
        yields hl

    pat lfr $1==6
        yields dede

/* Comparisons */

    pat cmi $1==3
        leaving
            sbi 3

    pat cmu $1==3
        leaving
            sbu 3

    pat cmi $1==6
        with hlhlreg dedereg
        gen
            Call {label, ".cmi6"}
        yields hl

    pat cmu $1==6
        with STACK
        gen
            Call {label, ".cmu6"}
        yields hl

    pat cmp
        leaving
            cmu 3

/* Branches */

    pat bra
        with STACK
        gen
            jp {label, $1}

    pat bne
        leaving
            sbi 3
            zne $1
            
    pat beq
        leaving
            sbi 3
            zeq $1
            
    pat ble
        leaving
            sbi 3
            zle $1

    pat blt
        leaving
            sbi 3
            zlt $1

    pat bge
        leaving
            sbi 3
            zge $1

    pat bgt
        leaving
            sbi 3
            zgt $1

    pat zeq
        with wreg STACK
        gen
            test %1
            jpz {label, $1}

    pat zne
        with wreg STACK
        gen
            test %1
            jpnz {label, $1}

    pat zlt
        with wreg
        gen
            test %1
            jpm {label, $1}

    pat zle
        with wreg STACK
        gen
            test %1
            jpz {label, $1}
            jpm {label, $1}

    pat zgt
        with wreg STACK
        gen
            test %1
            jrz {label, "1f"}
            jpp {label, $1}
        1:

    pat zge
        with wreg STACK
        gen
            test %1
            jpp {label, $1}

    pat tlt
        with wreg
        uses areg={const1, 0}
        gen
            test %1
            jrp {label, "1f"}
            inc a
        1:

    pat tgt
        with wreg
        uses areg={const1, 0}
        gen
            test %1
            jrz {label, "1f"}
            jrm {label, "1f"}
            inc a
        1:

    pat tne
        with wreg
        uses areg={const1, 0}
        gen
            test %1
            jrz {label, "1f"}
            inc a
        1:

    pat teq
        with wreg
        uses areg={const1, 0}
        gen
            test %1
            jrnz {label, "1f"}
            inc a
        1:

/* Weird miscellaneous stuff */

    pat lin
        leaving
            ste ".hol0"

    pat lni
        leaving
            ine ".hol0"
    
    pat fil
        leaving
            lae $1
            ste ".hol0"

    pat csa $1==3
        kills ALL
        gen
            jp {label, ".csa3"}
            
    pat csb $1==3
        kills ALL
        gen
            jp {label, ".csb3"}
            
    pat cms
        with STACK
        uses bcreg={const3, $1}
        gen
            Call {label, ".cms"}

    pat blm
        with hlreg dereg
        uses bcreg={const3, $1}
        gen
            ldir.

    pat lar $1==3
        with STACK
        kills ALL
        gen
            Call {label, ".lar3"}

    pat sar $1==3
        with STACK
        kills ALL
        gen
            Call {label, ".sar3"}

    pat lxl $1==0
        yields {stackaddr, 0}

    pat lxl $1==1
        leaving
            lxa 0
            dch

    pat lxa $1==0
        yields {stackaddr, 6}

    /* Follow dynamic chain; given a fp, get the fp of the caller */
    pat dch
        leaving
            loi 3

    pat gto
        with STACK
        gen
            ld sp, {memref3, $1+3}
            ld iy, {memref3, $1+6}
            ld hl, {memref3, $1+0}
            jp {regind, hl}

// vim: sw=4 ts=4 et

