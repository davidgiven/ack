EM_WSIZE = 3  /* size of a word */
EM_PSIZE = 3  /* size of a pointer */
EM_BSIZE = 6  /* two pointers saved in stack frame */

FP_OFFSET = 0 /* offset of saved FP relative to our FP */
PC_OFFSET = 3 /* offset of saved PC relative to our PC */

#define COMMENT(n) /* command {LABEL, n} */

PROPERTIES

    areg        /* the A register */
    breg        /* any byte-sized register */

    hlreg       /* the HL register */
    hlhlreg     /* the HLHL' register */
    bcreg       /* the BC register */
    dereg       /* the DE register */
    dedereg     /* the DEDE' register */
    xreg        /* IX */
    wreg        /* any word-sized register except IX */
    wxreg       /* any word-sized register including IX */
    dreg        /* any doubleword-sized register */
    spreg       /* the stack pointer */
    altreg      /* alternate bank registers */
    hlreg_or_dereg /* HL or DE */

REGISTERS

    a:                          areg, breg.
    b, c, d, e, h, l, ixh, ixl: breg.
    hl("hl")=l+h:               hlreg, wreg, wxreg, hlreg_or_dereg.
    bc("bc")=c+b:               bcreg, wreg, wxreg.
    de("de")=e+d:               dereg, wreg, wxreg, hlreg_or_dereg.
    ix("ix")=ixl+ixh:           xreg, wxreg.
    sp:                         spreg.

    hlhl("hl")=hl:              dreg, hlhlreg.
    bcbc("bc")=bc:              dreg.
    dede("de")=de:              dreg, dedereg.

TOKENS

    const1      = { INT num; } 1 num.
    const3      = { INT num; } 3 num.
    label       = { ADDR off; } 3 off.
    comment     = { ADDR str; } 0 "! " str.

    regind      = { wreg reg; } 3 "(" reg ")".
    indexref3   = { xreg reg; ADDR off; } 3 "(" reg "+" off ")".
    indexref6   = { xreg reg; ADDR off; } 6 "(" reg "+" off ")".
    memref3     = { ADDR off; } 3 "(" off ")".
    memref6     = { ADDR off; } 6 "(" off ")".
    stackaddr   = { ADDR off; } 3 "iy+" off .
    stackref3   = { ADDR off; } 3 "(iy+" off ")".
    stackref6   = { ADDR off; } 6 "(iy+" off ")".

SETS

    
    bc_de       = bcreg + dereg.
    hl_de       = hlreg + dereg.
    any_reg     = breg + wreg.
    any_int     = any_reg + const3 + label.
    any_long    = dreg.

INSTRUCTIONS

    Call "call" label:ro kills :cc.
    adc hlreg+hlhlreg:rw, wreg:ro kills :cc.
    add areg:rw, breg+const1:ro kills :cc.
    add hlreg+hlhlreg:rw, wreg:ro kills :cc.
    add hlreg:rw, spreg:ro kills :cc.
    and areg:rw:cc, const1+breg:ro.
    dec breg+wreg+spreg:rw:cc.
    ex dereg:rw, hlreg:rw.
    ex spreg, hlreg:rw.
    exx.
    inc breg+wreg+spreg:rw:cc.
    jp label:ro kills :cc.
    jpc "jp c," label:ro kills :cc.
    jpm "jp m," label:ro kills :cc.
    jpnc "jp nc," label:ro kills :cc.
    jpnz "jp nz," label:ro kills :cc.
    jpp "jp p," label:ro kills :cc.
    jpz "jp z," label:ro kills :cc.
    jr label:ro kills :cc.
    jrc "jp z," label:ro kills :cc.
    jrm "jp m," label:ro kills :cc.
    jrnc "jp nc," label:ro kills :cc.
    jrnz "jp nz," label:ro kills :cc.
    jrp "jp p," label:ro kills :cc.
    jrz "jp z," label:ro kills :cc.
    ld breg+wreg:wo:cc, stackref3+memref3+indexref6:ro.
    ld breg:wo:cc, breg+const1:ro.
    ld breg:wo:cc, memref3+regind:ro.
    ld indexref6:wo:cc, wreg:ro.
    ld memref3+stackref3:wo:cc, wreg:ro.
    ld regind:wo:cc, wreg:ro.
    ld spreg:wo:cc, hlreg:ro.
    ld wxreg:wo:cc, const1+const3+label+memref3+regind:ro.
    lea wxreg:wo:cc, stackaddr:ro.
    pea stackaddr:ro.
    pop wreg+xreg:wo.
    push wreg+xreg:ro.
    sbc hlreg+hlhlreg:rw:cc, wreg+spreg:ro.
    xor breg:ro:cc.


MOVES

    from const1 %num==0 to areg
        gen
            xor a

    from const1+breg to breg
        gen
            ld %2, %1

    from breg to wreg
        gen
            move %1, %2.1
            move {const1, 0}, %2.2

    from const1+const3 to wreg
        gen
            ld %2, %1

    from const1+const3 to dreg
        gen
            move %1, %2.1
            exx.
            move {const1, 0}, %2.1
            exx.

    from label to wreg
        gen
            ld %2, %1

    from label to xreg
        gen
            ld %2, %1

    from wxreg to wxreg
        gen
            push %1
            pop %2

TESTS

    to test hlreg
        gen
            Call {label, ".testhl3"}
            
    to test bcreg
        gen
            Call {label, ".testbc3"}
            
    to test dereg
        gen
            Call {label, ".testde3"}
            
STACKINGRULES

    from wreg+xreg to STACK
        gen
            push %1

    from dreg to STACK
        gen
            exx.
            push %1.1
            exx.
            push %1.1

    from const3+wreg+label to STACK
        uses wreg
        gen
            move %1, %a
            push %a

    from const3+wreg+label to STACK
        gen
            push hl
            move %1, hl
            ex sp, hl

    from const1+breg to STACK
        uses wreg
        gen
            move %1, %a
            push %a

    from const1+breg to STACK
        gen
            push hl
            move %1, hl
            ex sp, hl

    from stackaddr to STACK
        gen
            pea %1

    from memref3+stackref3 to STACK
        gen
            push hl
            ld hl, %1
            ex sp, hl

    from memref6 to STACK
        uses wreg
        gen
            ld %a, {memref3, %1.off+0}
            push %a
            ld %a, {memref3, %1.off+3}
            push %a

    from memref6 to STACK
        gen
            push hl
            ld hl, {memref3, %1.off+0}
            ex sp, hl
            push hl
            ld hl, {memref3, %1.off+3}
            ex sp, hl

COERCIONS

    from STACK
        uses wxreg
        gen
            pop %a
        yields %a

    from STACK
        uses dreg
        gen
            pop %a.1
            exx.
            pop %a.1
            exx.
        yields %a
    
    from hlreg_or_dereg
        uses hlreg_or_dereg
        gen
            ex de, hl
        yields %a

    from stackaddr
        uses wxreg
        gen
            lea %a, %1
        yields %a

    from label+const1+const3
        uses xreg
        gen
            ld %a, %1
        yields %a

    from stackref3
        uses wreg
        gen
            ld %a, %1
        yields %a

PATTERNS

/* Stack stuff */

    pat dup $1==3
        with any_int
        yields %1 %1

    pat dup $1==6
        with any_long
        yields %1 %1

    pat exg $1==3
        with any_int any_int
        yields %1 %2

    pat exg $1==6
        with any_long any_long
        yields %1 %2

    pat asp $1==0 /* do nothing */

    pat asp $1==1
        with STACK
        gen
            inc sp

    pat asp $1==0-1
        with STACK
        gen
            dec sp

    pat asp $1==3
        with STACK
        uses wreg
        gen
            pop %a
           
    pat asp
        with STACK
        uses hlreg={const3, $1}
        gen
            add hl, sp
            ld sp, hl

    pat loc
        yields {const3, $1}

/* Conversions */

    pat loc loc cuu
        leaving
            loc $1
            loc $2
            cuu

    pat loc loc cui
        leaving
            loc $1
            loc $2
            cuu

    pat cui
        leaving
            cuu $1

    pat ciu
        leaving
            cuu $1

    pat loc loc cuu $1==$2
    
    pat loc loc cuu $1==3 && $2==6
        with wreg+const3+label
        yields {const3, 0} %1

    pat loc loc cuu $1==6 && $2==3
        with wreg wreg
        yields %2

/* Loads and saves */

    pat lal
        yields {stackaddr, $1}

    pat loi $1==3
        with exact label
            yields {memref3, %1.off}
        with stackaddr
            yields {stackref3, %1.off}
        with wreg
            uses wreg
            gen
                ld %a, {regind, %1}
            yields %a

    pat loi $1==6
        with exact label
            yields {memref6, %1.off}
        with xreg
            uses dreg
            gen
                ld %a.1, {indexref6, %1, 0}
                exx.
                ld %a.1, {indexref6, %1, 3}
                exx.
            yields %a
        with stackaddr
            uses dreg
            gen
                ld %a.1, {stackref3, %1.off+0}
                exx.
                ld %a.1, {stackref3, %1.off+3}
                exx.
            yields %a
        
    pat sti $1==3
        with label wreg
            gen
                ld {memref3, %1.off}, %2
        with stackaddr wreg
            gen
                ld {stackref3, %1.off}, %2
        with wreg wreg
            gen
                ld {regind, %1}, %2

    pat lol
        leaving
            lal $1
            loi 3

    pat stl lol $1==$2
        with wreg
        yields
            %1 %1
        leaving
            stl $1

    pat stl
        leaving
            lal $1
            sti 3

    pat ldl
        leaving
            lal $1
            loi 6

    pat sdl
        leaving
            lal $1
            sti 6

    pat lae
        yields {label, $1}

    pat loe
        leaving
            lae $1
            loi 3

    pat lde
        leaving
            lae $1
            loi 6

    pat ste
        leaving
            lae $1
            sti 3
        
    pat sde
        leaving
            lae $1
            sti 6
        
    pat inl
        leaving
            lol $1
            inc
            stl $1

/* Arithmetic */

    pat adp
        leaving
            loc $1
            adi 3

    pat dec
        with wreg
        gen
            dec %1
        yields %1

    pat inc
        with wreg
        gen
            inc %1
        yields %1

    pat adi $1==3
        with hlreg wreg
            gen
                add %1, %2
            yields %1
        with wreg hlreg
            leaving
                exg 3
                adi 3

    pat adi $1==6
        with hlhlreg dreg
            gen
                add %1.1, %2.1
                exx.
                adc %1.1, %2.1
                exx.
            yields %1
        with dreg hlhlreg
            leaving
                exg 6
                adi 6

    pat sbi $1==3
        with hlreg wreg
        gen
            and a, a
            sbc %1, %2
        yields %1

    pat sbi $1==6
        with hlhlreg dreg
        gen
            and a, a
            sbc %1.1, %2.1
            exx.
            sbc %1.1, %2.1
            exx.
        yields %1

    pat ngi $1==3
        leaving
            loc 0
            exg 3
            sbi 3
        
    pat ngi $1==6
        leaving
            loc 0
            loc 0
            exg 6
            sbi 6
        
    pat ngi $1==6
        with bcreg+dereg
        uses hlreg={const3, 0}
        gen
            and a, a
            sbc %a, %1
        yields %a
        
/* Floating point arithmetic */

    pat cmf
        gen
            Call {label, ".cmf_unsupported"}

    pat ngf
        gen
            Call {label, ".ngf_unsupported"}

/* Subroutines and jumps */

    pat cal
        kills ALL
        gen
            Call {label, $1}

    pat cai
        with hlreg
        kills ALL
        gen
            Call {label, ".pchl"}

    pat ret $1==0
        with STACK
        gen
            jp {label, ".ret"}

    pat ret $1==3
        with dereg STACK
        gen
            jp {label, ".ret"}

    pat ret $1==6
        with dedereg STACK
        gen
            jp {label, ".ret"}

    pat lfr $1==3
        yields hl

    pat lfr $1==6
        yields dede

/* Comparisons */

    pat cmi $1==3
        leaving
            sbi 3

    pat cmu $1==3
        leaving
            sbu 3

    pat cmi $1==6
        with hlhlreg dedereg
        gen
            Call {label, ".cmi6"}
        yields hl

    pat cmu $1==6
        with STACK
        gen
            Call {label, ".cmu6"}
        yields hl

/* Branches */

    pat bra
        with STACK
        gen
            jp {label, $1}

    pat bne
        leaving
            sbi 3
            zne $1
            
    pat beq
        leaving
            sbi 3
            zeq $1
            
    pat ble
        with wreg hlreg STACK
        gen
            and a, a
            sbc %2, %1
            jpc {label, $1}
        with hlreg wreg STACK
        leaving
            exg 3
            bgt $1

    pat zeq
        with wreg STACK
        gen
            test %1
            jpz {label, $1}

    pat zne
        with wreg STACK
        gen
            test %1
            jpnz {label, $1}

    pat zlt
        with wreg STACK
        gen
            test %1
            jpm {label, $1}

    pat zgt
        with wreg STACK
        gen
            test %1
            jrz {label, "1f"}
            jpm {label, $1}
        1:

/* Weird miscellaneous stuff */

    pat lin
        leaving
            ste ".hol0"

    pat lni
        leaving
            ine ".hol0"


// vim: sw=4 ts=4 et

